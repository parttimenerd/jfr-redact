package me.bechberger.jfrredact.jfr;

import jdk.jfr.Configuration;
import jdk.jfr.Recording;
import me.bechberger.jfrredact.jfr.util.JFRTestHelper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Tests using real JDK JFR events (Thread.sleep, System.gc, JVMInformation, etc.)
 * to verify the redaction processor can handle actual JVM-generated events.
 *
 * These tests perform actual roundtrip processing through the redaction engine
 * using the existing test framework to ensure real-world events are preserved correctly.
 *
 * The comprehensive verification checks:
 * - All field values
 * - Field annotations and their values
 * - Event type annotations
 * - Field nullability
 * - Event metadata
 */
@SuppressWarnings({"SynchronizationOnLocalVariableOrMethodParameter"})
public class JFRRealWorldEventsTest {

    @TempDir
    Path tempDir;

    private JFRTestHelper helper;

    @BeforeEach
    void setUp() {
        helper = new JFRTestHelper(tempDir);
    }

    // ========== Thread.sleep Events - Roundtrip Tests ==========

    @Test
    public void testThreadSleepRoundtrip_NoRedaction() throws Exception {
        JFRTestHelper.RoundtripVerifier verifier = helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.start();

                Thread.sleep(10);
                Thread.sleep(20);
                Thread.sleep(15);

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();

        // Verify ThreadSleep events are fully preserved (if any were recorded)
        if (!verifier.getOriginalEventsOfType("jdk.ThreadSleep").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.ThreadSleep");
        }
    }

    @Test
    public void testThreadSleepRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.start();

                Thread.sleep(10);
                Thread.sleep(20);

                recording.stop();
            }
        })
        .withDefaultRedaction()
        // Verify specific event type count is preserved, not all events
        // (some JDK internal events may not survive roundtrip processing)
        .eventTypeCountPreserved("jdk.ThreadSleep");
    }

    @Test
    public void testThreadSleepRoundtrip_WithStrictRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.start();

                Thread.sleep(10);

                recording.stop();
            }
        })
        .withStrictRedaction()
        .eventTypeCountPreserved("jdk.ThreadSleep");
    }

    // ========== System.gc Events - Roundtrip Tests ==========

    @Test
    public void testGarbageCollectionRoundtrip_NoRedaction() throws Exception {
        JFRTestHelper.RoundtripVerifier verifier = helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.GarbageCollection");
                recording.enable("jdk.GCHeapSummary");
                recording.start();

                // Generate garbage and trigger GC
                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<byte[]> garbage = new ArrayList<>();
                for (int i = 0; i < 100; i++) {
                    garbage.add(new byte[10240]); // 10KB each
                }
                System.gc();
                Thread.yield();

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();

        // Verify GC events are fully preserved (if any were recorded)
        if (!verifier.getOriginalEventsOfType("jdk.GarbageCollection").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.GarbageCollection");
        }
        if (!verifier.getOriginalEventsOfType("jdk.GCHeapSummary").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.GCHeapSummary");
        }
    }

    @Test
    public void testGarbageCollectionRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.GarbageCollection");
                recording.enable("jdk.GCHeapSummary");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<byte[]> garbage = new ArrayList<>();
                for (int i = 0; i < 50; i++) {
                    garbage.add(new byte[10240]);
                }
                System.gc();

                recording.stop();
            }
        })
        .withDefaultRedaction()
        .eventCountPreserved();
    }

    @Test
    public void testGarbageCollectionRoundtrip_WithStrictRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.GarbageCollection");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<byte[]> garbage = new ArrayList<>();
                for (int i = 0; i < 50; i++) {
                    garbage.add(new byte[5120]);
                }
                System.gc();

                recording.stop();
            }
        })
        .withStrictRedaction()
        .eventCountPreserved();
    }

    // ========== JVM Information Events - Roundtrip Tests ==========

    @Test
    public void testJVMInformationRoundtrip_NoRedaction() throws Exception {
        JFRTestHelper.RoundtripVerifier verifier = helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.JVMInformation");
                recording.start();

                Thread.sleep(50);

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();

        // Verify JVM information events are fully preserved
        if (!verifier.getOriginalEventsOfType("jdk.JVMInformation").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.JVMInformation");
        }
    }

    @Test
    public void testJVMInformationRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.JVMInformation");
                recording.start();

                Thread.sleep(50);

                recording.stop();
            }
        })
        .withDefaultRedaction()
        .eventCountPreserved();
    }

    // ========== Object Allocation Events - Roundtrip Tests ==========

    @Test
    public void testObjectAllocationRoundtrip_NoRedaction() throws Exception {
        JFRTestHelper.RoundtripVerifier verifier = helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.enable("jdk.ObjectAllocationOutsideTLAB");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<Object> objects = new ArrayList<>();
                for (int i = 0; i < 100; i++) {
                    objects.add(new byte[1024]);
                    objects.add(new HashMap<String, String>());
                    objects.add("String " + i);
                }

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();

        // Verify allocation events are fully preserved (if any were recorded)
        if (!verifier.getOriginalEventsOfType("jdk.ObjectAllocationInNewTLAB").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.ObjectAllocationInNewTLAB");
        }
        if (!verifier.getOriginalEventsOfType("jdk.ObjectAllocationOutsideTLAB").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.ObjectAllocationOutsideTLAB");
        }
    }

    @Test
    public void testObjectAllocationRoundtrip_WithPseudonymization() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<Object> objects = new ArrayList<>();
                for (int i = 0; i < 50; i++) {
                    objects.add(new byte[512]);
                    objects.add("Test " + i);
                }

                recording.stop();
            }
        })
        .withPseudonymization()
        .eventCountPreserved();
    }

    // ========== Class Loading Events - Roundtrip Tests ==========

    @Test
    public void testClassLoadingRoundtrip_NoRedaction() throws Exception {
        JFRTestHelper.RoundtripVerifier verifier = helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ClassLoad");
                recording.enable("jdk.ClassDefine");
                recording.start();

                // Trigger class loading
                try {
                    Class.forName("java.util.concurrent.ConcurrentHashMap");
                    Class.forName("java.util.concurrent.atomic.AtomicInteger");
                    Class.forName("java.util.stream.Collectors");
                } catch (ClassNotFoundException e) {
                    // Ignore
                }

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();

        // Verify class loading events are fully preserved (if any were recorded)
        if (!verifier.getOriginalEventsOfType("jdk.ClassLoad").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.ClassLoad");
        }
        if (!verifier.getOriginalEventsOfType("jdk.ClassDefine").isEmpty()) {
            verifier.eventsOfTypeFullyPreserved("jdk.ClassDefine");
        }
    }

    @Test
    public void testClassLoadingRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ClassLoad");
                recording.start();

                try {
                    Class.forName("java.util.concurrent.ConcurrentLinkedQueue");
                } catch (ClassNotFoundException e) {
                    // Ignore
                }

                recording.stop();
            }
        })
        .withDefaultRedaction()
        .eventCountPreserved();
    }

    // ========== Exception Events - Roundtrip Tests ==========

    @Test
    public void testExceptionEventsRoundtrip_NoRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.JavaExceptionThrow");
                recording.start();

                for (int i = 0; i < 5; i++) {
                    try {
                        throw new IllegalArgumentException("Test exception " + i);
                    } catch (RuntimeException e) {
                        // Expected
                    }
                }

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();
    }

    @Test
    public void testExceptionEventsRoundtrip_WithStrictRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.JavaExceptionThrow");
                recording.start();

                for (int i = 0; i < 3; i++) {
                    try {
                        throw new IllegalStateException("Test " + i);
                    } catch (RuntimeException e) {
                        // Expected
                    }
                }

                recording.stop();
            }
        })
        .withStrictRedaction()
        .eventCountPreserved();
    }

    // ========== File I/O Events - Roundtrip Tests ==========

    @Test
    public void testFileIOEventsRoundtrip_NoRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.FileRead");
                recording.enable("jdk.FileWrite");
                recording.start();

                Path testFile = tempDir.resolve("test-io.txt");
                Files.writeString(testFile, "Test content\n".repeat(10));
                @SuppressWarnings("unused")
                String content = Files.readString(testFile);
                Files.delete(testFile);

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();
    }

    @Test
    public void testFileIOEventsRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.FileRead");
                recording.enable("jdk.FileWrite");
                recording.start();

                Path testFile = tempDir.resolve("test-file.txt");
                Files.writeString(testFile, "Content");
                Files.readString(testFile);
                Files.delete(testFile);

                recording.stop();
            }
        })
        .withDefaultRedaction()
        .eventCountPreserved();
    }

    // ========== Monitor Events - Roundtrip Tests ==========

    @Test
    public void testMonitorEventsRoundtrip_NoRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.JavaMonitorEnter");
                recording.enable("jdk.JavaMonitorWait");
                recording.start();

                Object lock = new Object();
                for (int i = 0; i < 3; i++) {
                    synchronized (lock) {
                        Thread.sleep(5);
                    }
                }

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();
    }

    // ========== Mixed Real-World Events - Roundtrip Tests ==========

    @Test
    public void testMixedRealWorldEventsRoundtrip_NoRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.enable("jdk.GarbageCollection");
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.enable("jdk.JavaExceptionThrow");
                recording.enable("jdk.JVMInformation");
                recording.start();

                // Generate various events
                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<Object> allocations = new ArrayList<>();
                for (int i = 0; i < 50; i++) {
                    allocations.add(new byte[1024]);
                }

                Thread.sleep(20);
                System.gc();

                try {
                    throw new RuntimeException("Test");
                } catch (RuntimeException e) {
                    // Expected
                }

                recording.stop();
            }
        })
        .withoutRedaction()
        .eventCountPreserved();
    }

    @Test
    public void testMixedRealWorldEventsRoundtrip_WithDefaultRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.enable("jdk.GarbageCollection");
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<Object> allocations = new ArrayList<>();
                for (int i = 0; i < 30; i++) {
                    allocations.add(new byte[512]);
                }

                Thread.sleep(15);
                System.gc();

                recording.stop();
            }
        })
        .withDefaultRedaction()
        .eventCountPreserved();
    }

    @Test
    public void testMixedRealWorldEventsRoundtrip_WithPseudonymization() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.ThreadSleep").withThreshold(Duration.ofMillis(1));
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.enable("jdk.JavaExceptionThrow");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<Object> allocations = new ArrayList<>();
                for (int i = 0; i < 20; i++) {
                    allocations.add("Test" + i);
                }

                Thread.sleep(10);

                try {
                    throw new IllegalArgumentException("Test");
                } catch (RuntimeException e) {
                    // Expected
                }

                recording.stop();
            }
        })
        .withPseudonymization()
        .eventCountPreserved();
    }

    @Test
    public void testMixedRealWorldEventsRoundtrip_WithStrictRedaction() throws Exception {
        helper.roundtrip(() -> {
            try (Recording recording = new Recording(Configuration.getConfiguration("default"))) {
                recording.enable("jdk.GarbageCollection");
                recording.enable("jdk.ObjectAllocationInNewTLAB");
                recording.start();

                @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
                List<byte[]> garbage = new ArrayList<>();
                for (int i = 0; i < 20; i++) {
                    garbage.add(new byte[512]);
                }
                System.gc();

                recording.stop();
            }
        })
        .withStrictRedaction()
        .eventCountPreserved();
    }
}